<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Vector Fury - Lives Mechanic Mod</title>
    
    <meta name="description" content="Play Vector Fury, a fast-paced, full-viewport arcade game. Capture targets, use power-ups, and avoid hazards in this vector-style shooter. Now with lives and growing player!">
    <meta name="keywords" content="vector fury, chris pirillo, vector game, arcade game, html5 game, javascript game, online game, geometry wars style, power-ups, retro game, lives system">
    <meta name="author" content="Chris Pirillo (Modified by Gemini)">
    <meta name="publisher" content="Chris Pirillo">
    <link rel="canonical" href="https://pirillo.com/arcade/vector-fury.html">

    <meta property="og:title" content="Vector Fury - Lives Mechanic Mod">
    <meta property="og:description" content="A thrilling vector-style arcade game. Capture targets, grab power-ups, and survive with limited lives as your ship grows!">
    <meta property="og:image" content="https://pirillo.com/arcade/images/vector-fury.png">
    <meta property="og:url" content="https://pirillo.com/arcade/vector-fury.html">
    <meta property="og:type" content="website">
    <meta property="og:site_name" content="Chris Pirillo's Arcade">

    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="Vector Fury - Lives Mechanic Mod">
    <meta name="twitter:description" content="Blast your way through vector shapes in this exciting HTML5 arcade game with a new lives and growth mechanic.">
    <meta name="twitter:image" content="https://pirillo.com/arcade/images/vector-fury.png">
    <meta name="twitter:creator" content="@ChrisPirillo">

    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;500;700&display=swap" rel="stylesheet">

    <script type="application/ld+json">
    {
      "@context": "https://schema.org",
      "@type": "VideoGame",
      "name": "Vector Fury (Lives Mod)",
      "url": "https://pirillo.com/arcade/vector-fury.html",
      "author": {
        "@type": "Person",
        "name": "Chris Pirillo"
      },
      "publisher": {
        "@type": "Person",
        "name": "Chris Pirillo"
      },
      "image": "https://pirillo.com/arcade/images/vector-fury.png",
      "description": "A fast-paced, full-viewport vector-style arcade game where players capture targets, use power-ups, and avoid hazards, now with a lives system and player growth mechanic.",
      "applicationCategory": "Game",
      "gamePlatform": ["PC", "WebBrowser"],
      "operatingSystem": "All",
      "genre": ["Arcade game", "Action game"],
      "playMode": "SinglePlayer",
      "keywords": "vector game, arcade, html5, javascript, retro, shooter, action, lives",
      "offers": {
        "@type": "Offer",
        "price": "0",
        "priceCurrency": "USD"
      }
    }
    </script>

    <style>
        body {
            font-family: 'Orbitron', sans-serif; 
            background-color: #000010; 
            color: #e0e0e0;
            display: flex; 
            justify-content: center;
            align-items: center;
            height: 100vh; 
            width: 100vw; 
            margin: 0;
            padding: 0;
            overflow: hidden; 
            overscroll-behavior-y: contain;
            user-select: none; 
            -webkit-user-select: none; 
            -moz-user-select: none; 
            -ms-user-select: none; 
        }
        .game-container {
            position: relative;
            width: 100%; 
            height: 100%; 
            background-color: #000010; 
        }
        #gameCanvas {
            display: block;
            width: 100%;
            height: 100%;
            /* CSS cursor is now fully managed by JS in gameLoop */
            touch-action: none; 
            user-select: none; 
            -webkit-user-select: none; 
            -moz-user-select: none; 
            -ms-user-select: none; 
        }
        .ui-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            pointer-events: none; 
            padding: 20px; 
            box-sizing: border-box;
            user-select: none; 
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
        }
        .ui-overlay .screen {
            background-color: rgba(0, 10, 30, 0.9); 
            padding: 2rem; 
            border-radius: 0.75rem; 
            text-align: center;
            box-shadow: 0 0 25px rgba(0, 128, 255, 0.35); 
            pointer-events: auto; 
            border: 1px solid rgba(0, 128, 255, 0.5); 
            max-width: 95%; 
            width: auto; 
            min-width: 320px; 
            display: flex; 
            flex-direction: column;
            align-items: center;
        }
        .ui-overlay button {
            background-color: rgba(0, 136, 255, 0.75); 
            color: #00ffff; 
            padding: 0.8rem 1.8rem; 
            border: 1px solid #00ddff; 
            border-radius: 0.375rem; 
            font-size: 1.1rem; 
            font-weight: 500; 
            cursor: pointer; 
            transition: background-color 0.2s ease, color 0.2s ease, transform 0.1s ease, box-shadow 0.2s ease;
            margin-top: 1.5rem; 
            box-shadow: 0 0 12px rgba(0, 221, 255, 0.5);
            text-shadow: 0 0 6px rgba(0, 221, 255, 0.6);
            user-select: none; 
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
        }
        .ui-overlay button:hover {
            background-color: rgba(0, 180, 255, 0.9); 
            color: #ffffff;
            transform: scale(1.05);
            box-shadow: 0 0 18px rgba(0, 221, 255, 0.7);
        }
        .ui-overlay button:active {
            transform: scale(0.98);
        }

        #score-display {
            position: absolute;
            top: 25px; 
            left: 25px; 
            font-size: 1.75rem; 
            font-weight: 700; 
            color: #00ffdd; 
            text-shadow: 0 0 5px #00ffdd, 0 0 8px rgba(0, 255, 221, 0.5); 
            pointer-events: none;
            z-index: 100; 
            display: none; /* Initially hidden */
        }
        #lives-display { 
            position: absolute;
            top: 65px; 
            left: 25px;
            font-size: 1.5rem; 
            font-weight: 700;
            color: #fff700; 
            text-shadow: 0 0 5px #fff700, 0 0 8px rgba(255, 247, 0, 0.5);
            pointer-events: none;
            z-index: 100;
            display: none; 
        }
        #powerup-timer-display {
            position: absolute;
            top: 25px;
            right: 25px;
            font-size: 1.25rem;
            font-weight: 500;
            text-shadow: 0 0 6px currentColor; 
            pointer-events: none;
            z-index: 100;
            display: none; 
        }


        .screen h1, .screen h2 { 
            font-weight: 700; 
            margin-bottom: 1.25rem; 
            text-transform: uppercase;
            letter-spacing: 2.5px; 
        }

        .screen h1 { 
            font-size: 2.75rem; 
            color: #00ffdd; 
            text-shadow: 0 0 10px #00ffdd, 0 0 15px #00ffdd;
        }
        #gameOver-screen {
             border: 1px solid rgba(255, 77, 77, 0.7); 
             box-shadow: 0 0 25px rgba(255, 77, 77, 0.4), inset 0 0 10px rgba(255, 77, 77, 0.2);
             padding-top: 2rem; 
             padding-bottom: 2.5rem;
        }
        #gameOver-screen h2 { 
            font-size: 2.75rem; 
            color: #ff3333; 
            text-shadow: 0 0 9px #ff3333, 0 0 14px #ff3333; 
            margin-bottom: 1rem; 
        }
        #finalScoreText { 
            font-size: 1.1rem;
            font-weight: 400;
            color: #cccccc;
            margin-bottom: 0.25rem; 
            text-shadow: none;
        }
        #finalScoreValue { 
            font-size: 2rem !important; 
            font-weight: 700; 
            color: #fff700; 
            margin-bottom: 1.75rem !important; 
            text-shadow: 0 0 8px #fff700, 0 0 12px #fff700;
        }
        
        #start-screen .objectives-container {
            display: flex;
            flex-wrap: wrap; 
            justify-content: center; 
            gap: 0.75rem; 
            width: 100%;
            margin-top: 0.75rem; 
            margin-bottom: 1rem; 
        }
        .objective-card {
            background-color: rgba(0, 20, 50, 0.65); 
            border: 1px solid rgba(0, 100, 150, 0.5);
            border-radius: 0.5rem;
            padding: 0.75rem; 
            width: 105px; 
            min-height: 140px; 
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: space-between; 
            text-align: center;
            box-shadow: 0 0 10px rgba(0,128,255,0.2);
        }
        .objective-card .action {
            font-size: 0.8rem; 
            font-weight: 500;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 0.3rem; 
        }
        .objective-card .shape-icon-container { 
            width: 40px; 
            height: 40px;
            display: flex;
            justify-content: center;
            align-items: center;
            margin-bottom: 0.3rem; 
        }
        .objective-card .shape-icon-container svg {
            width: 100%;
            height: 100%;
            filter: drop-shadow(0 0 3px currentColor); 
        }
        .objective-card .effect {
            font-size: 0.85rem; 
            font-weight: 500; 
            color: #dddddd; 
            line-height: 1.2;
        }

        .text-white-star { color: #ffffff; }
        .text-purple-hex { color: #c084fc; }
        .text-green-400 { color: #34d399; }
        .text-red-400   { color: #f87171; }
        .text-yellow-400 { color: #facc15; }
        .font-bold { font-weight: 700; }

        #attribution-button {
            position: absolute;
            bottom: 15px;
            right: 15px;
            background-color: rgba(0, 0, 0, 0.4);
            color: #aaa;
            padding: 5px 10px;
            border-radius: 3px;
            font-size: 0.75rem;
            text-decoration: none;
            transition: color 0.2s ease, background-color 0.2s ease;
            z-index: 1000; 
            pointer-events: auto; 
            user-select: none; 
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
        }
        #attribution-button:hover {
            background-color: rgba(0, 136, 255, 0.6);
            color: #fff;
        }

    </style>
</head>
<body>
    <div class="game-container">
        <canvas id="gameCanvas"></canvas>
        <div class="ui-overlay">
            <div id="score-display">0</div> 
            <div id="lives-display">Lives: 10</div> 
            <div id="powerup-timer-display"></div> 
            <div id="start-screen" class="screen">
                <h1>Vector Fury</h1>
                <div class="objectives-container">
                    <div class="objective-card">
                        <p class="action" style="color: #00ffdd;">Capture</p>
                        <div class="shape-icon-container text-green-400">
                            <svg viewBox="0 0 20 20" fill="none" stroke="currentColor" stroke-width="1.5">
                                <rect x="3" y="3" width="14" height="14" rx="1"/>
                            </svg>
                        </div>
                        <p class="effect">10 Points</p>
                    </div>
                    <div class="objective-card">
                        <p class="action" style="color: #00ffdd;">Capture</p>
                        <div class="shape-icon-container text-yellow-400">
                            <svg viewBox="0 0 20 20" fill="none" stroke="currentColor" stroke-width="1.5">
                                <path d="M10 2L17 10L10 18L3 10L10 2Z"/>
                            </svg>
                        </div>
                        <p class="effect">50 Points</p>
                    </div>
                    <div class="objective-card">
                        <p class="action" style="color: #00ffdd;">Capture</p>
                        <div class="shape-icon-container text-white-star">
                             <svg viewBox="0 0 20 20" fill="none" stroke="currentColor" stroke-width="1.2">
                                <path d="M10 1.5L12.18 6.82L18 7.64L13.91 11.91L15.09 17.5L10 14.77L4.91 17.5L6.09 11.91L2 7.64L7.82 6.82L10 1.5Z"/>
                            </svg>
                        </div>
                        <p class="effect">Attract</p>
                    </div>
                    <div class="objective-card">
                        <p class="action" style="color: #ff6b6b;">Avoid</p> 
                        <div class="shape-icon-container text-purple-hex">
                            <svg viewBox="0 0 20 20" fill="none" stroke="currentColor" stroke-width="1.5">
                                <path d="M10 2.5L16.5 6.25V13.75L10 17.5L3.5 13.75V6.25L10 2.5Z"/>
                            </svg>
                        </div>
                        <p class="effect">Repel</p>
                    </div>
                    <div class="objective-card">
                        <p class="action" style="color: #ff6b6b;">Avoid</p>
                        <div class="shape-icon-container text-red-400">
                            <svg viewBox="0 0 20 20" fill="none" stroke="currentColor" stroke-width="1.5">
                                <circle cx="10" cy="10" r="7"/>
                            </svg>
                        </div>
                        <p class="effect">Lose</p> </div>
                </div>
                <button id="startButton">Start Game</button>
            </div>
            <div id="gameOver-screen" class="screen" style="display:none;">
                <h2>Game Over</h2>
                <p id="finalScoreText">Final Score</p>
                <p id="finalScoreValue">0</p>
                <button id="restartButton">Restart Game</button>
            </div>
        </div>
        <a href="https://chrispirillo.bio.link/" target="_blank" id="attribution-button">@ChrisPirillo</a>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const canvas = document.getElementById('gameCanvas');
            if (!canvas) {
                console.error("Fatal Error: Canvas element not found. Check HTML structure.");
                return;
            }
            const ctx = canvas.getContext('2d');
            if (!ctx) {
                console.error("Fatal Error: Could not get 2D rendering context. Ensure canvas is supported.");
                return;
            }

            const scoreDisplay = document.getElementById('score-display');
            const livesDisplay = document.getElementById('lives-display'); 
            const powerupTimerDisplay = document.getElementById('powerup-timer-display');
            const startScreen = document.getElementById('start-screen');
            const gameOverScreen = document.getElementById('gameOver-screen');
            const finalScoreValueDisplay = document.getElementById('finalScoreValue'); 

            const startButton = document.getElementById('startButton');
            const restartButton = document.getElementById('restartButton');

            let CANVAS_WIDTH = window.innerWidth;
            let CANVAS_HEIGHT = window.innerHeight;
            
            let player; 
            let gameState = 'menu'; // Initial game state: menu, playing, gameOver

            const PLAYER_INITIAL_LIVES = 10; // Initial number of lives
            let playerLives = PLAYER_INITIAL_LIVES;
            const PLAYER_GROWTH_PER_HIT = 5; // How much the player grows when hit

            let isGravityStarActive = false; // Power-up state
            let gravityStarTimer = 0; // Timer for gravity star power-up
            const GRAVITY_STAR_DURATION = 15 * 60; // Duration in frames (assuming 60fps)

            let isRepelBurstActive = false; // Power-up state for repel burst
            let repelBurstTimer = 0; // Timer for repel burst
            const REPEL_BURST_DURATION = 5 * 60; // Duration in frames
            
            // Touch input state variables
            let isTouching = false;
            let touchStartX = 0;
            let touchStartY = 0;
            let playerStartOnTouchX = 0;
            let playerStartOnTouchY = 0;
            
            // Target position for player movement (smooth follow)
            let targetPlayerX = CANVAS_WIDTH / 2;
            let targetPlayerY = CANVAS_HEIGHT / 2;
            
            // Style for hiding the system cursor during gameplay
            const gameplayCursorStyle = 'none'; // Use 'none' to hide the cursor
            const defaultCursorStyle = 'default'; // Default cursor for menus


            // Function to resize the canvas and adjust game elements
            function resizeCanvas() {
                CANVAS_WIDTH = window.innerWidth;
                CANVAS_HEIGHT = window.innerHeight;
                canvas.width = CANVAS_WIDTH;
                canvas.height = CANVAS_HEIGHT;
                
                // Recalculate target player position if not actively touching
                if (player && !isTouching) {
                    targetPlayerX = player.x;
                    targetPlayerY = player.y;
                } else if (!player) { 
                     targetPlayerX = CANVAS_WIDTH / 2; 
                     targetPlayerY = CANVAS_HEIGHT / 2;
                }

                // Adjust player properties on resize
                if (player) { 
                    player.recalculateSizeOnResize(); 
                    // Keep player within bounds
                    player.x = Math.max(player.radius, Math.min(player.x, CANVAS_WIDTH - player.radius));
                    player.y = Math.max(player.radius, Math.min(player.y, CANVAS_HEIGHT - player.radius));
                }
                
                // Adjust enemy sizes on resize
                enemies.forEach(enemy => {
                    const baseSize = Math.min(CANVAS_WIDTH, CANVAS_HEIGHT) * 0.02;
                    if (enemy.type === 'target') enemy.radius = baseSize * 1.2;
                    else if (enemy.type === 'avoid_circle') enemy.radius = baseSize * 0.9; 
                    else if (enemy.type === 'special') enemy.radius = baseSize * 0.9;
                    else if (enemy.type === 'powerup_gravity_star') enemy.radius = baseSize * 1.1; 
                    else if (enemy.type === 'powerup_repel_burst') enemy.radius = baseSize * 1.1; 
                });

                // Redraw grid if not in active play (e.g., on menu/game over screens after resize)
                if(gameState !== 'playing' && ctx) { 
                    drawGrid(); 
                }
            }
            window.addEventListener('resize', resizeCanvas); // Add resize event listener

            // Game variables
            let score = 0;
            let enemies = []; // Array to hold enemy objects
            let particles = []; // Array to hold particle objects for effects
            let enemySpawnTimer = 0;
            let enemySpawnInterval = 120; // Initial interval for spawning enemies (frames)
            const MIN_ENEMY_SPAWN_INTERVAL = 25; // Minimum spawn interval
            const YELLOW_DIAMOND_CHANCE = 0.07; // Chance to spawn a special yellow diamond
            const WHITE_STAR_CHANCE = 0.025; // Chance to spawn a gravity star power-up
            const PURPLE_HEX_REPEL_CHANCE = 0.025; // Chance to spawn a repel burst power-up


            // Player class definition
            class Player {
                constructor() {
                    this.baseSize = Math.min(CANVAS_WIDTH, CANVAS_HEIGHT) * 0.025; 
                    this.growthAmount = 0; // Amount player has grown due to hits
                    this.currentSize = this.baseSize + this.growthAmount;
                    
                    this.x = CANVAS_WIDTH / 2;
                    this.y = CANVAS_HEIGHT / 2;
                    targetPlayerX = this.x; 
                    targetPlayerY = this.y;
                    this.angle = -Math.PI / 2; // Initial angle (pointing up)
                    this.targetAngle = -Math.PI / 2; // Target angle for smooth rotation
                    this.rotationSpeed = 0.18; // Speed of rotation
                    this.color = '#00ffff'; // Player color
                    this.glowColor = 'rgba(0, 255, 255, 0.7)'; // Player glow color
                    this.glowBlur = 15; // Player glow blur radius
                    this.radius = this.currentSize * 0.6; // Collision radius
                    this.lineWidth = 2; // Line width for drawing

                    // Store original visual properties for power-up reversion
                    this.originalGlowColor = this.glowColor;
                    this.originalLineWidth = this.lineWidth;
                    this.originalGlowBlur = this.glowBlur;
                    this.originalColor = this.color;
                }

                // Update player state each frame
                update() {
                    const prevX = this.x;
                    const prevY = this.y;
                    
                    // Move player towards the target position (set by mouse/touch)
                    this.x = targetPlayerX;
                    this.y = targetPlayerY;

                    // Keep player within canvas boundaries
                    this.x = Math.max(this.radius, Math.min(this.x, CANVAS_WIDTH - this.radius));
                    this.y = Math.max(this.radius, Math.min(this.y, CANVAS_HEIGHT - this.radius));
                    
                    const dx = this.x - prevX; // Change in x
                    const dy = this.y - prevY; // Change in y

                    // Update target angle based on movement direction
                    if (Math.abs(dx) > 0.2 || Math.abs(dy) > 0.2) { // Only update if moved significantly
                       this.targetAngle = Math.atan2(dy, dx) + Math.PI / 2; 
                    }

                    // Smoothly rotate towards the target angle
                    let angleDiff = this.targetAngle - this.angle;
                    while (angleDiff > Math.PI) angleDiff -= 2 * Math.PI; // Normalize angle difference
                    while (angleDiff < -Math.PI) angleDiff += 2 * Math.PI;
                    this.angle += angleDiff * this.rotationSpeed;
                }

                // Increase player size when hit
                grow() {
                    this.growthAmount += PLAYER_GROWTH_PER_HIT;
                    this.currentSize = this.baseSize + this.growthAmount;
                    this.radius = this.currentSize * 0.6;

                    // Cap player size to prevent it from becoming too large
                    const maxPlayerSize = Math.min(CANVAS_WIDTH, CANVAS_HEIGHT) * 0.20; 
                    if (this.currentSize > maxPlayerSize) {
                        this.currentSize = maxPlayerSize;
                        this.growthAmount = this.currentSize - this.baseSize; 
                        this.radius = this.currentSize * 0.6;
                    }
                }

                // Reset player size and growth (e.g., on game start)
                resetSizeAndGrowth() {
                    this.baseSize = Math.min(CANVAS_WIDTH, CANVAS_HEIGHT) * 0.025;
                    this.growthAmount = 0;
                    this.currentSize = this.baseSize;
                    this.radius = this.currentSize * 0.6;
                }

                // Recalculate size based on current growth when canvas is resized
                recalculateSizeOnResize() {
                    this.baseSize = Math.min(CANVAS_WIDTH, CANVAS_HEIGHT) * 0.025;
                    this.currentSize = this.baseSize + this.growthAmount;
                    this.radius = this.currentSize * 0.6;
                }
                
                // Change player appearance for gravity star power-up
                activateGravityVisuals() {
                    this.color = '#FFFFFF'; 
                    this.glowColor = 'rgba(220, 220, 255, 1)'; 
                    this.glowBlur = this.originalGlowBlur + 8;
                    this.lineWidth = this.originalLineWidth + 1;
                }
                // Change player appearance for repel burst power-up
                activateRepelVisuals() {
                    this.color = '#c084fc'; 
                    this.glowColor = 'rgba(200, 100, 255, 1)'; 
                    this.glowBlur = this.originalGlowBlur + 8;
                    this.lineWidth = this.originalLineWidth + 1;
                }
                // Revert player appearance to normal
                deactivatePowerVisuals() { 
                    this.color = this.originalColor;
                    this.glowColor = this.originalGlowColor;
                    this.glowBlur = this.originalGlowBlur;
                    this.lineWidth = this.originalLineWidth;
                }

                // Draw the player on the canvas
                draw() {
                    ctx.save(); // Save current canvas state
                    ctx.translate(this.x, this.y); // Move origin to player position
                    ctx.rotate(this.angle); // Rotate canvas to player angle
                    
                    // Apply glow effect
                    ctx.shadowColor = this.glowColor;
                    ctx.shadowBlur = this.glowBlur;

                    // Draw player shape (triangle)
                    ctx.strokeStyle = this.color;
                    ctx.lineWidth = this.lineWidth;
                    ctx.beginPath();
                    ctx.moveTo(0, -this.currentSize * 0.8); // Top point
                    ctx.lineTo(this.currentSize * 0.6, this.currentSize * 0.7); // Bottom-right point
                    ctx.lineTo(-this.currentSize * 0.6, this.currentSize * 0.7); // Bottom-left point
                    ctx.closePath();
                    ctx.stroke(); 

                    ctx.restore(); // Restore canvas state
                    ctx.shadowBlur = 0; // Reset shadow blur for other drawings
                }
            }

            // Enemy class definition
            class Enemy { 
                constructor(type) {
                    this.type = type; 
                    this.lineWidth = 2; 
                    const baseSize = Math.min(CANVAS_WIDTH, CANVAS_HEIGHT) * 0.02; // Base size relative to canvas

                    // Properties based on enemy type
                    if (type === 'target') { // Green square - collect for points
                        this.radius = baseSize * 1.2; 
                        this.color = '#00ff00'; 
                        this.glowColor = 'rgba(0, 255, 0, 0.7)';
                        this.glowBlur = 12;
                        this.shape = 'square';
                        this.points = 10;
                    } else if (type === 'avoid_circle') { // Red circle - avoid
                        this.radius = baseSize * 0.9; 
                        this.color = '#ff0000'; 
                        this.glowColor = 'rgba(255, 0, 0, 0.7)';
                        this.glowBlur = 15;
                        this.shape = 'circle';
                        this.points = 0; 
                    } else if (type === 'special') { // Yellow diamond - collect for more points
                        this.radius = baseSize * 0.9; 
                        this.color = '#fff700'; 
                        this.glowColor = 'rgba(255, 247, 0, 0.8)';
                        this.glowBlur = 18;
                        this.shape = 'diamond';
                        this.points = 50;
                    } else if (type === 'powerup_gravity_star') { // White star - gravity power-up
                        this.radius = baseSize * 1.1; 
                        this.color = '#FFFFFF'; 
                        this.glowColor = 'rgba(255, 255, 255, 0.9)';
                        this.glowBlur = 22;
                        this.shape = 'star';
                        this.points = 0; 
                    } else if (type === 'powerup_repel_burst') { // Purple hexagon - repel power-up
                        this.radius = baseSize * 1.1; 
                        this.color = '#c084fc'; 
                        this.glowColor = 'rgba(192, 132, 252, 0.9)';
                        this.glowBlur = 20;
                        this.shape = 'hexagon';
                        this.points = 0;
                    }

                    // Spawn enemy from one of the four edges
                    const edge = Math.floor(Math.random() * 4);
                    if (edge === 0) { // Top edge
                        this.x = Math.random() * CANVAS_WIDTH;
                        this.y = -this.radius - 10; // Start off-screen
                    } else if (edge === 1) { // Right edge
                        this.x = CANVAS_WIDTH + this.radius + 10;
                        this.y = Math.random() * CANVAS_HEIGHT;
                    } else if (edge === 2) { // Bottom edge
                        this.x = Math.random() * CANVAS_WIDTH;
                        this.y = CANVAS_HEIGHT + this.radius + 10;
                    } else { // Left edge
                        this.x = -this.radius - 10;
                        this.y = Math.random() * CANVAS_HEIGHT;
                    }

                    // Calculate initial velocity towards the center of the canvas
                    const angleToCenter = Math.atan2(CANVAS_HEIGHT / 2 - this.y, CANVAS_WIDTH / 2 - this.x);
                    this.speed = (1 + Math.random() * 1.5 + (score / 500)) * (Math.min(CANVAS_WIDTH, CANVAS_HEIGHT)/700); // Speed increases with score and canvas size
                    this.baseVx = Math.cos(angleToCenter) * this.speed;
                    this.baseVy = Math.sin(angleToCenter) * this.speed;
                    this.vx = this.baseVx; // Current x-velocity
                    this.vy = this.baseVy; // Current y-velocity
                }

                // Update enemy state each frame
                update() {
                    this.vx = this.baseVx; // Reset to base velocity
                    this.vy = this.baseVy;

                    // Apply gravity star effect if active
                    if (isGravityStarActive && (this.type === 'target' || this.type === 'special') && player) {
                        const angleToPlayer = Math.atan2(player.y - this.y, player.x - this.x);
                        const suckInSpeed = 5 + (score / 1000); // Attraction speed increases with score
                        this.vx = Math.cos(angleToPlayer) * suckInSpeed;
                        this.vy = Math.sin(angleToPlayer) * suckInSpeed;
                    } 
                    // Apply repel burst effect if active
                    else if (isRepelBurstActive && (this.type === 'target' || this.type === 'special' || this.type === 'powerup_gravity_star') && player) {
                        const angleFromPlayer = Math.atan2(this.y - player.y, this.x - player.x); 
                        const repelSpeed = 6; 
                        this.vx = Math.cos(angleFromPlayer) * repelSpeed;
                        this.vy = Math.sin(angleFromPlayer) * repelSpeed;
                    }

                    this.x += this.vx; // Update position
                    this.y += this.vy;
                }

                // Draw the enemy on the canvas
                draw() {
                    ctx.save();
                    ctx.shadowColor = this.glowColor;
                    ctx.shadowBlur = this.glowBlur;
                    
                    ctx.strokeStyle = this.color; 
                    ctx.lineWidth = this.lineWidth;

                    // Draw shape based on enemy type
                    if (this.shape === 'square') {
                        ctx.beginPath();
                        ctx.rect(this.x - this.radius, this.y - this.radius, this.radius * 2, this.radius * 2);
                        ctx.stroke(); 
                    } else if (this.shape === 'circle') {
                        ctx.beginPath();
                        ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                        ctx.stroke(); 
                    } else if (this.shape === 'diamond') {
                        ctx.beginPath();
                        ctx.moveTo(this.x, this.y - this.radius); 
                        ctx.lineTo(this.x + this.radius * 0.7, this.y); 
                        ctx.lineTo(this.x, this.y + this.radius); 
                        ctx.lineTo(this.x - this.radius * 0.7, this.y); 
                        ctx.closePath();
                        ctx.stroke();
                    } else if (this.shape === 'star') {
                        this.drawStar(5, this.radius, this.radius * 0.5); // 5 points, outer/inner radius
                    } else if (this.shape === 'hexagon') {
                        this.drawHexagon(this.radius);
                    }
                    ctx.restore();
                    ctx.shadowBlur = 0;
                }
            }
            
            // Helper function to draw a star shape (added to Enemy prototype)
            Enemy.prototype.drawStar = function(spikes, outerRadius, innerRadius) { 
                let rot = Math.PI / 2 * 3; // Initial rotation
                let x = this.x;
                let y = this.y;
                const step = Math.PI / spikes; // Angle between points

                ctx.beginPath();
                ctx.moveTo(this.x, this.y - outerRadius); // Start at top point
                for (let i = 0; i < spikes; i++) {
                    // Outer point
                    x = this.x + Math.cos(rot) * outerRadius;
                    y = this.y + Math.sin(rot) * outerRadius;
                    ctx.lineTo(x, y);
                    rot += step;

                    // Inner point
                    x = this.x + Math.cos(rot) * innerRadius;
                    y = this.y + Math.sin(rot) * innerRadius;
                    ctx.lineTo(x, y);
                    rot += step;
                }
                ctx.lineTo(this.x, this.y - outerRadius); // Close path
                ctx.closePath();
                ctx.stroke();
            };

            // Helper function to draw a hexagon shape (added to Enemy prototype)
            Enemy.prototype.drawHexagon = function(radius) { 
                ctx.beginPath();
                for (let i = 0; i < 6; i++) {
                    ctx.lineTo(this.x + radius * Math.cos(Math.PI / 3 * i + Math.PI / 6), // Angle adjustment for flat top
                               this.y + radius * Math.sin(Math.PI / 3 * i + Math.PI / 6));
                }
                ctx.closePath();
                ctx.stroke();
            };


            // Particle class definition (for explosion effects)
            class Particle { 
                constructor(x, y, color, glowColor) {
                    this.x = x;
                    this.y = y;
                    this.size = Math.random() * 2.5 + 1.5; // Random size
                    this.vx = (Math.random() - 0.5) * (Math.random() * 6); // Random horizontal velocity
                    this.vy = (Math.random() - 0.5) * (Math.random() * 6); // Random vertical velocity
                    this.life = 20 + Math.random() * 20; // Lifetime in frames
                    this.color = color;
                    this.glowColor = glowColor || color;
                    this.glowBlur = 4; 
                }

                // Update particle state each frame
                update() {
                    this.x += this.vx;
                    this.y += this.vy;
                    this.vy += 0.03; // Simple gravity effect
                    this.life -= 1; // Decrease life
                    this.size *= 0.97; // Shrink particle
                }

                // Draw the particle on the canvas
                draw() {
                    if (this.life <= 0 || this.size < 0.3) return; // Don't draw if dead or too small
                    ctx.save();
                    ctx.globalAlpha = Math.max(0, this.life / 30); // Fade out
                    ctx.fillStyle = this.color; 
                    ctx.shadowColor = this.glowColor;
                    ctx.shadowBlur = this.glowBlur;
                    ctx.beginPath();
                    // Draw as small squares, but fillRect is simpler than arc for tiny particles
                    ctx.fillRect(this.x - this.size / 2, this.y - this.size / 2, this.size, this.size);
                    ctx.restore();
                    ctx.shadowBlur = 0; // Reset shadow
                    ctx.globalAlpha = 1.0; // Reset alpha
                }
            }

            // Function to create an explosion of particles
            function createExplosion(x, y, objectType) { 
                let count = 15; // Default particle count
                let baseColor = player ? player.color : '#00ffff'; // Default color
                let glow = player ? player.glowColor : 'rgba(0,255,255,0.7)';

                // Customize particles based on the object type
                if (objectType === 'target') {
                    count = 12; baseColor = '#00ff00'; glow = 'rgba(0,255,0,0.7)';
                } else if (objectType === 'avoid_circle') { 
                    count = 25; baseColor = '#ff0000'; glow = 'rgba(255,0,0,0.7)';
                } else if (objectType === 'special') { 
                    count = 20; baseColor = '#fff700'; glow = 'rgba(255,247,0,0.8)';
                } else if (objectType === 'powerup_gravity_star') {
                    count = 35; baseColor = '#FFFFFF'; glow = 'rgba(220,220,255,0.9)'; 
                } else if (objectType === 'powerup_repel_burst') {
                    count = 35; baseColor = '#c084fc'; glow = 'rgba(192,132,252,0.9)';
                } else if (objectType === 'playerHit') { // Player hit explosion
                    count = 18; 
                }
            
                for (let i = 0; i < count; i++) {
                    particles.push(new Particle(x, y, baseColor, glow));
                }
            }

            // Initialize or reset the game state
            function initGame() {
                resizeCanvas(); // Ensure canvas is sized correctly
                if (!player) { // Create player if it doesn't exist
                    player = new Player();
                }
                player.resetSizeAndGrowth(); // Reset player size

                playerLives = PLAYER_INITIAL_LIVES; 
                enemies = []; // Clear enemies
                particles = []; // Clear particles
                score = 0;
                enemySpawnTimer = 0;
                enemySpawnInterval = 120; // Reset spawn interval
                isGravityStarActive = false; 
                gravityStarTimer = 0;
                isRepelBurstActive = false;
                repelBurstTimer = 0;
                isTouching = false; // Reset touch state

                if(powerupTimerDisplay) powerupTimerDisplay.style.display = 'none'; // Hide power-up timer
                if(player) player.deactivatePowerVisuals(); // Reset player visuals

                updateScoreDisplay(); // Update score display (will show 0)
                updateLivesDisplay(); // Update lives display
                gameState = 'playing'; // Set game state to active play
                if(startScreen) startScreen.style.display = 'none'; // Hide start screen
                if(gameOverScreen) gameOverScreen.style.display = 'none'; // Hide game over screen
                
                // Show game UI elements
                if(scoreDisplay) scoreDisplay.style.display = 'block'; // Show score
                if(livesDisplay) livesDisplay.style.display = 'block'; // Show lives
            }

            // Update the score display on the screen
            function updateScoreDisplay() {
                if(scoreDisplay) scoreDisplay.textContent = `${score}`;
            }
            // Update the lives display on the screen
            function updateLivesDisplay() { 
                if(livesDisplay) livesDisplay.textContent = `Lives: ${playerLives}`;
            }
            // Update the power-up timer display on the screen
            function updatePowerupTimerDisplay() { 
                if (!powerupTimerDisplay) return;
                if (isGravityStarActive) {
                    powerupTimerDisplay.style.display = 'block';
                    powerupTimerDisplay.style.color = '#FFFFFF'; 
                    powerupTimerDisplay.textContent = `GRAVITY: ${(gravityStarTimer / 60).toFixed(1)}s`;
                } else if (isRepelBurstActive) {
                    powerupTimerDisplay.style.display = 'block';
                    powerupTimerDisplay.style.color = '#c084fc'; 
                    powerupTimerDisplay.textContent = `REPEL: ${(repelBurstTimer / 60).toFixed(1)}s`;
                } else { 
                    powerupTimerDisplay.style.display = 'none'; // Hide if no power-up active
                }
            }


            // Spawn a new enemy
            function spawnEnemy() { 
                let type;
                const rand = Math.random(); // Random number for type selection
                let cumulativeChance = 0;

                // Determine enemy type based on weighted chances
                cumulativeChance += WHITE_STAR_CHANCE;
                if (rand < cumulativeChance) { 
                    type = 'powerup_gravity_star';
                } else {
                    cumulativeChance += PURPLE_HEX_REPEL_CHANCE; 
                    if (rand < cumulativeChance) {
                        type = 'powerup_repel_burst';
                    } else {
                        cumulativeChance += YELLOW_DIAMOND_CHANCE;
                        if (rand < cumulativeChance) { 
                            type = 'special'; // Yellow diamond
                        } else {
                            cumulativeChance += 0.55; // Higher chance for regular targets/avoid_circles
                            if (rand < cumulativeChance) { 
                                type = 'target'; // Green square
                            } else { 
                                type = 'avoid_circle'; // Red circle
                            }
                        }
                    }
                }
                enemies.push(new Enemy(type)); // Add new enemy to the array
            }

            // Handle collisions between player and enemies
            function handleCollisions() {
                if (!player) return;
                for (let i = enemies.length - 1; i >= 0; i--) { // Iterate backwards for safe removal
                    const e = enemies[i];
                    const dist = Math.hypot(player.x - e.x, player.y - e.y); // Distance between player and enemy

                    if (dist < player.radius + e.radius) { // Collision detected
                        if (e.type === 'target' || e.type === 'special') { // Collectible enemy
                            createExplosion(e.x, e.y, e.type); // Create explosion at enemy location
                            enemies.splice(i, 1); // Remove enemy
                            score += e.points; // Add points
                            updateScoreDisplay();
                            // Decrease spawn interval slightly, making game harder
                            enemySpawnInterval = Math.max(MIN_ENEMY_SPAWN_INTERVAL, enemySpawnInterval - (e.type === 'special' ? 1.2 : 0.6)); 
                        } else if (e.type === 'powerup_gravity_star') { // Gravity star power-up
                            createExplosion(e.x, e.y, e.type);
                            enemies.splice(i, 1);
                            isGravityStarActive = true;
                            gravityStarTimer = GRAVITY_STAR_DURATION;
                            isRepelBurstActive = false; // Deactivate other power-up if active
                            if(player) player.activateGravityVisuals();
                            updatePowerupTimerDisplay(); 
                        } else if (e.type === 'powerup_repel_burst') { // Repel burst power-up
                            createExplosion(e.x, e.y, e.type);
                            enemies.splice(i, 1);
                            isRepelBurstActive = true;
                            repelBurstTimer = REPEL_BURST_DURATION;
                            isGravityStarActive = false; // Deactivate other power-up
                            if(player) player.activateRepelVisuals();
                            updatePowerupTimerDisplay();
                        } else if (e.type === 'avoid_circle') { // Avoidable enemy (hazard)
                            createExplosion(player.x, player.y, 'playerHit'); // Explosion at player location
                            createExplosion(e.x, e.y, e.type); // Explosion at enemy location
                            enemies.splice(i, 1); // Remove enemy

                            playerLives--; // Decrease lives
                            updateLivesDisplay(); 

                            if (player) {
                                player.grow(); // Player grows when hit (visual feedback, makes it harder)
                            }

                            if (playerLives <= 0) { // Check for game over
                                triggerGameOver(`Ran out of lives after hitting a ${e.shape}!`);
                                return; // Exit collision handling
                            }
                        }
                    }
                }
            }
            
            // Trigger the game over state
            function triggerGameOver(reason) {
                if (gameState === 'gameOver') return; // Prevent multiple triggers
                console.log("Game Over:", reason);
                gameState = 'gameOver';
                if(finalScoreValueDisplay) finalScoreValueDisplay.textContent = `${score}`; // Show final score
                if(gameOverScreen) gameOverScreen.style.display = 'flex'; // Show game over screen
                
                // Hide in-game UI elements
                if(scoreDisplay) scoreDisplay.style.display = 'none'; 
                if(livesDisplay) livesDisplay.style.display = 'none'; 
                
                // Deactivate power-ups
                isGravityStarActive = false; 
                isRepelBurstActive = false;
                if(powerupTimerDisplay) powerupTimerDisplay.style.display = 'none';
                if(player) player.deactivatePowerVisuals(); // Reset player appearance
            }

            // Draw the background grid
            function drawGrid() { 
                if (!ctx) return; 
                ctx.strokeStyle = "rgba(0, 80, 130, 0.2)"; // Grid line color
                ctx.lineWidth = 0.5; // Grid line width
                const gridSize = Math.min(CANVAS_WIDTH, CANVAS_HEIGHT) * 0.05; // Grid cell size relative to canvas
                // Draw vertical lines
                for (let x = 0; x <= CANVAS_WIDTH; x += gridSize) {
                    ctx.beginPath();
                    ctx.moveTo(x, 0);
                    ctx.lineTo(x, CANVAS_HEIGHT);
                    ctx.stroke();
                }
                // Draw horizontal lines
                for (let y = 0; y <= CANVAS_HEIGHT; y += gridSize) {
                    ctx.beginPath();
                    ctx.moveTo(0, y);
                    ctx.lineTo(CANVAS_WIDTH, y);
                    ctx.stroke();
                }
            }

            // Main game loop function
            function gameLoop() { 
                if (!ctx || !canvas) return; // Ensure canvas context is available

                // Clear canvas with background color
                ctx.fillStyle = '#000010'; 
                ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
                drawGrid(); // Draw background grid

                // Update power-up timers
                if (isGravityStarActive) {
                    gravityStarTimer--;
                    updatePowerupTimerDisplay();
                    if (gravityStarTimer <= 0) {
                        isGravityStarActive = false;
                        if(player) player.deactivatePowerVisuals();
                        updatePowerupTimerDisplay(); 
                    }
                }
                if (isRepelBurstActive) {
                    repelBurstTimer--;
                    updatePowerupTimerDisplay();
                    if (repelBurstTimer <= 0) {
                        isRepelBurstActive = false;
                        if(player) player.deactivatePowerVisuals();
                        updatePowerupTimerDisplay(); 
                    }
                }

                // Game logic for 'playing' state
                if (gameState === 'playing') {
                    // Set canvas cursor to 'none' to hide system cursor
                    if (canvas.style.cursor !== gameplayCursorStyle) { 
                        canvas.style.cursor = gameplayCursorStyle;
                    }
                    if (player) {
                        player.update(); 
                        player.draw();
                    }

                    // Update and draw enemies
                    for (let i = enemies.length - 1; i >= 0; i--) {
                        enemies[i].update();
                        enemies[i].draw();
                        // Remove enemies far off-screen
                        const removeDist = Math.max(CANVAS_WIDTH, CANVAS_HEIGHT) * 1.5; 
                        if (enemies[i].x < -removeDist || enemies[i].x > CANVAS_WIDTH + removeDist ||
                            enemies[i].y < -removeDist || enemies[i].y > CANVAS_HEIGHT + removeDist) {
                            enemies.splice(i, 1);
                        }
                    }
                    
                    // Update and draw particles
                    for (let i = particles.length - 1; i >= 0; i--) {
                        particles[i].update();
                        particles[i].draw();
                        if (particles[i].life <= 0 || particles[i].size < 0.3) { // Remove dead/small particles
                            particles.splice(i, 1);
                        }
                    }

                    // Spawn new enemies periodically
                    enemySpawnTimer++;
                    if (enemySpawnTimer >= enemySpawnInterval) {
                        spawnEnemy();
                        enemySpawnTimer = 0;
                        // Gradually decrease spawn interval to increase difficulty
                        enemySpawnInterval = Math.max(MIN_ENEMY_SPAWN_INTERVAL, enemySpawnInterval * 0.98); 
                    }
                    
                    handleCollisions(); // Check for collisions

                } else if (gameState === 'menu' || gameState === 'gameOver') {
                    // Revert to default cursor for menu/game over screens
                    if (canvas.style.cursor !== defaultCursorStyle) { 
                        canvas.style.cursor = defaultCursorStyle;
                    }
                    // Keep particles animating on menu/game over screens for visual effect
                    for (let i = particles.length - 1; i >= 0; i--) {
                        particles[i].update();
                        particles[i].draw();
                        if (particles[i].life <= 0 || particles[i].size < 0.3) {
                            particles.splice(i, 1);
                        }
                    }
                }
                
                requestAnimationFrame(gameLoop); // Request next frame for smooth animation
            }

            // Get pointer position (mouse or touch) relative to the canvas
            function getPointerPos(event) { 
                const rect = canvas.getBoundingClientRect(); // Get canvas position and size
                let x, y;
                if (event.touches && event.touches.length > 0) { // Touch event
                    x = event.touches[0].clientX - rect.left;
                    y = event.touches[0].clientY - rect.top;
                } else { // Mouse event
                    x = event.clientX - rect.left;
                    y = event.clientY - rect.top;
                }
                return { x, y };
            }

            // Handle interaction start (mousedown or touchstart)
            function handleInteractionStart(event) {
                event.preventDefault(); // Prevent default browser actions (e.g., scrolling)
                if (gameState !== 'playing' || !player) return; // Only act if game is playing

                const pos = getPointerPos(event);
                if (event.touches) { // Touch input
                    isTouching = true;
                    touchStartX = pos.x; // Record initial touch position
                    touchStartY = pos.y;
                    playerStartOnTouchX = player.x; // Record player position at touch start
                    playerStartOnTouchY = player.y;
                    targetPlayerX = player.x; // Set target to current player pos initially for touch
                    targetPlayerY = player.y;
                } else { // Mouse input
                    targetPlayerX = pos.x; // Set target directly to mouse position
                    targetPlayerY = pos.y;
                }
            }

            // Handle interaction move (mousemove or touchmove)
            function handleInteractionMove(event) {
                event.preventDefault();
                if (gameState !== 'playing' || !player) return;

                const pos = getPointerPos(event);
                if (isTouching && event.touches) { // Touch input (dragging)
                    const deltaX = pos.x - touchStartX; // Calculate movement delta
                    const deltaY = pos.y - touchStartY;
                    targetPlayerX = playerStartOnTouchX + deltaX; // Update target based on drag
                    targetPlayerY = playerStartOnTouchY + deltaY;
                } else if (!event.touches) { // Mouse input
                    targetPlayerX = pos.x; // Update target directly to mouse position
                    targetPlayerY = pos.y;
                }
            }
            
            // Handle interaction end (mouseup, mouseleave, touchend, touchcancel)
            function handleInteractionEnd(event) {
                if (event.changedTouches) { // If it was a touch event
                     isTouching = false; // Reset touch state
                }
            }
            
            // Add event listeners for mouse and touch input
            if(canvas) {
                canvas.addEventListener('mousedown', handleInteractionStart); 
                canvas.addEventListener('mousemove', handleInteractionMove);
                canvas.addEventListener('mouseup', handleInteractionEnd); 
                canvas.addEventListener('mouseleave', handleInteractionEnd); // Stop player movement if mouse leaves canvas

                // Passive: false to allow preventDefault() for touch events
                canvas.addEventListener('touchstart', handleInteractionStart, { passive: false });
                canvas.addEventListener('touchmove', handleInteractionMove, { passive: false });
                canvas.addEventListener('touchend', handleInteractionEnd, { passive: false });
                canvas.addEventListener('touchcancel', handleInteractionEnd, { passive: false }); 
            }
            
            // Add event listeners for UI buttons
            if(startButton) startButton.addEventListener('click', () => { initGame(); });
            if(restartButton) restartButton.addEventListener('click', () => { initGame(); });
            
            // Initial setup
            resizeCanvas(); // Size canvas correctly on load
            requestAnimationFrame(gameLoop); // Start the game loop
        });
    </script>
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-1CQ4D3VQ3L"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
      gtag('config', 'G-1CQ4D3VQ3L');
    </script>
</body>
</html>
